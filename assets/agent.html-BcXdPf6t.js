import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,d as t,o as i}from"./app-CtETMgoo.js";const s={};function r(l,a){return i(),n("div",null,a[0]||(a[0]=[t(`<h3 id="java-agent的底层原理" tabindex="-1"><a class="header-anchor" href="#java-agent的底层原理"><span>Java Agent的底层原理</span></a></h3><blockquote><p>在理解之前，先注意下premain这个方法。</p></blockquote><p>Java Agent 是一种特殊的类加载机制，可以在 Java 应用程序启动时，向 JVM 动态加载并附加 Java 代理（Agent）代码。这些代理代码通常用于操作字节码、监控应用行为、进行日志记录、性能分析等。</p><h4 id="_1-java-agent-基本概念" tabindex="-1"><a class="header-anchor" href="#_1-java-agent-基本概念"><span>1. <strong>Java Agent 基本概念</strong></span></a></h4><p>Java Agent 是基于 Java Instrumentation API 的。Java Instrumentation 是一种扩展 Java 平台的机制，允许我们修改正在运行的 Java 程序的字节码或运行时行为。通过 <code>-javaagent</code> 参数，我们可以将代理 JAR 文件注入到 JVM 中，并可以动态修改类加载器行为、字节码的加载和转换等。</p><h4 id="_2-java-agent-的工作原理" tabindex="-1"><a class="header-anchor" href="#_2-java-agent-的工作原理"><span>2. <strong>Java Agent 的工作原理</strong></span></a></h4><p>Java Agent 的工作原理可以分为以下几个主要步骤：</p><h5 id="_1-启动时加载代理" tabindex="-1"><a class="header-anchor" href="#_1-启动时加载代理"><span><strong>(1) 启动时加载代理</strong></span></a></h5><p>当 JVM 启动时，如果指定了 <code>-javaagent</code> 参数，JVM 会读取该参数指定的代理 JAR 文件，并加载这个文件中的代码。这个 JAR 文件中的 <code>premain</code> 方法将作为代理的入口。</p><ul><li><code>-javaagent:/path/to/agent.jar</code>：此参数告诉 JVM 在应用启动时加载并执行指定的 Java Agent。</li><li><code>premain</code> 方法：代理类必须实现一个 <code>premain</code> 方法，JVM 在启动时会调用此方法。<code>premain</code> 方法接受两个参数： <ul><li><code>String agentArgs</code>：这是传给代理的参数。</li><li><code>Instrumentation inst</code>：这是一个 Instrumentation 对象，允许代理操作字节码，修改类的加载、方法的字节码等。</li></ul></li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MyAgent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> premain</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> agentArgs</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Instrumentation</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> inst</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 在此处可以注册类转换器、修改字节码等</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Java Agent initialized with args: &quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> agentArgs);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_2-字节码转换" tabindex="-1"><a class="header-anchor" href="#_2-字节码转换"><span><strong>(2) 字节码转换</strong></span></a></h5><p>通过 Instrumentation 对象，代理可以注册字节码转换器。这些转换器会在类加载时修改类的字节码，通常用于插桩（比如代码覆盖率工具、性能分析工具等）。</p><ul><li><code>inst.addTransformer(ClassFileTransformer transformer)</code>：用于注册字节码转换器。</li><li>这个转换器会在类加载时对字节码进行修改，插入自定义的逻辑（如性能监控、日志记录、方法执行时间统计等）。</li></ul><h5 id="_3-classloader-代理" tabindex="-1"><a class="header-anchor" href="#_3-classloader-代理"><span><strong>(3) ClassLoader 代理</strong></span></a></h5><p>Java Agent 也可以通过代理类加载器来改变类的加载方式。这种方式可以在运行时动态地改变类的字节码、生成新的类等。</p><h4 id="_3-常用-api-和方法" tabindex="-1"><a class="header-anchor" href="#_3-常用-api-和方法"><span>3. <strong>常用 API 和方法</strong></span></a></h4><p>Java Agent 主要通过 <code>Instrumentation</code> 类来实现字节码操作。以下是一些常用的 API：</p><ul><li><strong><code>Instrumentation.addTransformer()</code></strong>：添加字节码转换器。</li><li><strong><code>Instrumentation.getAllLoadedClasses()</code></strong>：获取所有加载的类。</li><li><strong><code>Instrumentation.retransformClasses()</code></strong>：重新变换已加载的类。</li><li><strong><code>ClassFileTransformer.transform()</code></strong>：这是字节码转换器的核心方法，它可以对类的字节码进行修改。</li></ul><h4 id="_4-java-agent-的实际用途" tabindex="-1"><a class="header-anchor" href="#_4-java-agent-的实际用途"><span>4. <strong>Java Agent 的实际用途</strong></span></a></h4><p>Java Agent 主要用于以下几个场景：</p><ul><li><strong>性能监控和分析</strong>：通过插桩代码，记录方法调用、执行时间、性能指标等。</li><li><strong>代码覆盖率</strong>：通过修改字节码来插入代码覆盖率相关的逻辑，帮助开发人员进行测试覆盖率分析。</li><li><strong>日志记录</strong>：通过代理插桩记录详细的日志，帮助排查问题。</li><li><strong>动态字节码生成和修改</strong>：例如，框架在运行时生成字节码来创建代理对象（如 Spring AOP）。</li></ul><h3 id="相关文章推荐" tabindex="-1"><a class="header-anchor" href="#相关文章推荐"><span>相关文章推荐</span></a></h3><p>以下是一些关于 Java Agent 和 Instrumentation 原理的专业文章和资源：</p><ol><li><p><strong><a href="https://dilfuruz.com/java-instrumentation-underlying-technology-behind-monitoring-tools/" target="_blank" rel="noopener noreferrer">Java Instrumentation: The Underlying Technology Behind Monitoring Tools</a></strong></p><ul><li>这篇文章介绍了 Java Instrumentation 的基本概念，并分析了如何通过 Instrumentation API 实现性能监控、字节码修改等功能。特别适合想要理解底层原理的人。</li></ul></li><li><p><strong><a href="https://www.baeldung.com/java/java-agent" target="_blank" rel="noopener noreferrer">Java Agent and Instrumentation</a></strong></p><ul><li>Baeldung 上的一篇文章，详细介绍了 Java Agent 的概念、如何实现 Agent 以及如何使用 Instrumentation API 来修改字节码，适合 Java 开发者学习。</li></ul></li><li><p><strong><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/package-summary.html" target="_blank" rel="noopener noreferrer">Java Instrumentation API</a></strong></p><ul><li>这是 Oracle 官方文档，提供了关于 Java Instrumentation API 的详细说明。可以帮助你理解如何实现代理并在运行时修改 Java 类。</li></ul></li><li><p><strong><a href="https://www.journaldev.com/7276/java-instrumentation" target="_blank" rel="noopener noreferrer">Bytecode Engineering Using the Java Instrumentation API</a></strong></p><ul><li>这篇文章讲解了如何使用 Java Instrumentation API 来处理字节码工程，解释了 <code>ClassFileTransformer</code> 的用法和如何实现类的字节码转换。</li></ul></li><li><p><strong><a href="https://www.javacodegeeks.com/2013/07/deep-dive-into-java-agents-with-examples.html" target="_blank" rel="noopener noreferrer">Deep Dive into Java Agents with Examples</a></strong></p><ul><li>这篇文章详细介绍了 Java Agent 的实现，并给出了实际的代码示例，帮助读者理解如何通过 Java Agent 来操作字节码，进行性能监控等。</li></ul></li></ol><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p>Java Agent 是一个强大的工具，通过 Java Instrumentation API，我们可以在应用程序运行时动态地修改字节码，插入额外的逻辑。它不仅可以用于性能监控、代码覆盖率分析、日志记录等功能，也为开发者提供了深入操作 Java 程序的能力。理解其底层原理有助于我们更好地利用这一特性进行各种系统优化和调试。</p>`,27)]))}const p=e(s,[["render",r],["__file","agent.html.vue"]]),g=JSON.parse(`{"path":"/java/agent.html","title":"java中的agent","lang":"en-US","frontmatter":{"title":"java中的agent","description":"Java Agent的底层原理 在理解之前，先注意下premain这个方法。 Java Agent 是一种特殊的类加载机制，可以在 Java 应用程序启动时，向 JVM 动态加载并附加 Java 代理（Agent）代码。这些代理代码通常用于操作字节码、监控应用行为、进行日志记录、性能分析等。 1. Java Agent 基本概念 Java Agent ...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/document/java/agent.html"}],["meta",{"property":"og:site_name","content":"ling's doc"}],["meta",{"property":"og:title","content":"java中的agent"}],["meta",{"property":"og:description","content":"Java Agent的底层原理 在理解之前，先注意下premain这个方法。 Java Agent 是一种特殊的类加载机制，可以在 Java 应用程序启动时，向 JVM 动态加载并附加 Java 代理（Agent）代码。这些代理代码通常用于操作字节码、监控应用行为、进行日志记录、性能分析等。 1. Java Agent 基本概念 Java Agent ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-04-20T09:50:39.000Z"}],["meta",{"property":"article:author","content":"Ling"}],["meta",{"property":"article:modified_time","content":"2025-04-20T09:50:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"java中的agent\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-04-20T09:50:39.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Ling\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":3,"title":"Java Agent的底层原理","slug":"java-agent的底层原理","link":"#java-agent的底层原理","children":[]},{"level":3,"title":"相关文章推荐","slug":"相关文章推荐","link":"#相关文章推荐","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1745142639000,"updatedTime":1745142639000,"contributors":[{"name":"lh","email":"992610900@qq.com","commits":1}]},"readingTime":{"minutes":4.2,"words":1261},"filePathRelative":"java/agent.md","localizedDate":"April 20, 2025","autoDesc":true}`);export{p as comp,g as data};
